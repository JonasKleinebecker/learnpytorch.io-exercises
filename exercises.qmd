---
title: "PyTorch Exercises"
jupyter: python3
---

## Imports 
```{python}
import numpy as np
import torch
import torch.nn as nn
from matplotlib import pyplot as plt
```

## PyTorch Exercises 00 pytorch fundamentals
https://www.learnpytorch.io/00_pytorch_fundamentals/#exercises
```{python}
torch.manual_seed(42)
torch.cuda.manual_seed(1234)
x = torch.randn(7 ,7)
y = torch.randn(1 ,7)
z = torch.matmul(x, y.T)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
torch.manual_seed(42)
gpu_1 = torch.randn(2 ,3).to(device)
torch.manual_seed(42)
gpu_2 = torch.randn(2 ,3).to(device)

gpu_3 = torch.matmul(gpu_1, gpu_2.T)

print(gpu_3.max())
print(gpu_3.argmax())
print(gpu_3.reshape(4)[3])

print(gpu_3.argmin())

torch.manual_seed(7)
original_tensor = torch.randn(1, 1, 1, 10)
squeezed_tensor = original_tensor.squeeze()
print(original_tensor.shape, original_tensor)
print(squeezed_tensor.shape, squeezed_tensor)
```

## PyTorch Exercises 01 pytorch Workflow fundamentals
```{python}
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
x = torch.arange(0, 1, 0.0025, dtype=torch.float32).unsqueeze(dim=1).to(device)
print(x.shape)
target_bias = 0.9
target_weight = 0.3
y = target_bias + target_weight * x

training_split = int(0.8 * len(x))

x_train, y_train = x[:training_split], y[:training_split]
x_val, y_val = x[training_split:], y[training_split:]

plt.scatter(x_train.cpu(), y_train.cpu(), label="train", color="blue")
plt.scatter(x_val.cpu(), y_val.cpu(), label="validation", color="orange")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.show()

class LinearRegression(nn.Module):
  def __init__(self):
    super().__init__()
    self.weight = nn.Parameter(torch.randn(1, device=device))
    self.bias = nn.Parameter(torch.randn(1, device=device))
    
  def forward(self, x):
    return self.weight * x + self.bias

torch.manual_seed(2)
model_0 = LinearRegression()

loss_fn = nn.L1Loss()
optimizer = torch.optim.SGD(model_0.parameters(), lr=0.02)

nun_epochs = 300 

epochs = []
train_losses = []
val_losses = []

for epoch in range(nun_epochs):
  model_0.train()
  
  y_pred = model_0(x_train)
  
  loss = loss_fn(y_pred, y_train)

  optimizer.zero_grad()

  loss.backward()

  optimizer.step()
  
  model_0.eval()
  
  with torch.inference_mode():
    y_val_pred = model_0(x_val)
    val_loss = loss_fn(y_val_pred, y_val)
  
  epochs.append(epoch)
  train_losses.append(loss.item())
  val_losses.append(val_loss.item())
  
  if epoch % 20 == 0:
    print(f"epoch {epoch+1}: train loss {loss}, val loss {val_loss}")

plt.plot(epochs, train_losses, label="train")
plt.plot(epochs, val_losses, label="val")
plt.xlabel("epoch")
plt.ylabel("loss")
plt.legend()
plt.show()

with torch.inference_mode():
  y_pred = model_0(x_val)

plt.scatter(x_train.detach().cpu(), y_train.detach().cpu(), label="train", color="green")
plt.scatter(x_val.cpu(), y_val.cpu(), label="validation", color="orange")
plt.scatter(x_val.cpu(), y_pred.cpu(), label="predictions", color="blue")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.show()

torch.save(model_0.state_dict(), "model_0.pth")

model_0_loaded = LinearRegression()
model_0_loaded.load_state_dict(torch.load("model_0.pth"))
with torch.inference_mode():
  y_pred = model_0_loaded(x_val)

plt.scatter(x_train.detach().cpu(), y_train.detach().cpu(), label="train", color="green")
plt.scatter(x_val.cpu(), y_val.cpu(), label="validation", color="orange")
plt.scatter(x_val.cpu(), y_pred.cpu(), label="predictions", color="blue")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.show()
```
